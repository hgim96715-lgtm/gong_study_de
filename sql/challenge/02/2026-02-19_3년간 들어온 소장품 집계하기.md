---
tags:
  - SQL_TEST
related:
  - "[[00_SQL_Challenge_DashBoard]]"
  - "[[SQL_CASE_WHEN]]"
source: programmers
difficulty:
  - Lv.2
status: 🟧 복습
---
##  해결 전략 (Code Before Think)

> 2014년부터 2016년까지 3년간 어떤 분류의 소장품이 많이 추가되었는지 알고자 합니다.
>   각 행은 분류(`classification`) 컬럼 기준으로 오름차순 정렬되어 있어야 합니다.
>   소장 일시를 알수 없는 일부 소장품의 경우, 예전에 소장된 작품이므로 2013년 이전에 소장된 작품으로 간주합니다. 
>   또한, 집계하는 3년간 추가된 소장품이 없더라도 이전 년도에 소장품이 있는 분류라면 해당 분류를 결과 테이블에 포함해주세요.

1. **타겟 데이터:** (어떤 테이블에서 무엇을 뽑아야 하는가?)
   - `artworks` 테이블
   - `acquisition_date` 소장일시
   - ` artwork_id` 작품 ID
   - `classification` 분류
1. **조건 분석:**
   - 2014-2016 3년간
   - 소장일시 알수 없음 (IS NULL)-> 2013년 이전 포함하면 x
   - 
1. **사용할 문법:**
   - 
---
## 정답 쿼리 (Solution)

```sql
-- 여기에 작성한 쿼리를 붙여넣으세요.
SELECT classification,
COUNT(CASE WHEN EXTRACT(YEAR FROM acquisition_date) = 2014 THEN 1 END) AS "2014",
COUNT(CASE WHEN EXTRACT(YEAR FROM acquisition_date) = 2015 THEN 1 END) AS "2015",
COUNT(CASE WHEN EXTRACT(YEAR FROM acquisition_date) = 2016 THEN 1 END) AS "2016"
FROM artworks
GROUP BY classification
```

---
##  오답 노트 & 배운 점 (Retrospective)

-  **내가 실수한 부분:**
	- 연도별 집계를 해야 하는 문제에서 **연도를 행(row)으로 만들기 위해 CTE를 생성하고 JOIN**하려고 접근했다.
	- 또한 연도 기준으로 JOIN 또는 WHERE 조건을 걸 경우,  **해당 기간에 소장품이 하나도 없는 분류(classification)가 결과에서 누락될 수 있음**을 고려하지 못했다.
    
-  **새로 알게 된 함수/꿀팁:**
	- **연도별 컬럼 집계는 JOIN이 아니라 조건부 집계(Conditional Aggregation)** 로 해결하는 것이 훨씬 간단하다
	- **요구 결과가 “컬럼 형태”인지 “행 형태”인지 먼저 파악하는 것이 중요**하다는 점을 배웠다.

>연도별 컬럼을 만들 때는 연도를 GROUP BY 하지 않고,  CASE WHEN을 이용한 조건부 집계로 처리한다.

---
## 더 나은 풀이가 있다면?

```sql
-- 더 나은 풀이가 있을경우 
```
