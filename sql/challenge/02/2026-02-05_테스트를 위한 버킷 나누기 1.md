---
tags:
  - SQL_TEST
related:
  - "[[SQL_CASE_WHEN]]"
  - "[[Aggregation_GROUP_BY]]"
  - "[[SQL_DISTINCT_vs_GROUP_BY]]"
source: solvesql
difficulty:
  - Lv.1
status:
  - 🟥 실패
  - 🟨 힌트참고
  - 🟩 해결
  - 🟧 복습
  - 🟨 진행중
  - 🟪 복습후 해결함
---
##  해결 전략 (Code Before Think)

> 당신은 고객 ID가 연속된 정수라는 점에 착안해 10으로 나눈 나머지가 0인 사용자를 그룹 A, 나머지 사용자를 그룹 B에 배정하고 A 그룹에 배정된 사용자만 신규 디자인을 보도록 작업하고자 합니다.
> 데이터베이스를 조회해 전체 고객별 할당된 그룹을 구하는 쿼리를 작성해주세요
> 고객 ID 기준 오름차순 정렬되어 있어야 합니다.

1. **타겟 데이터:** (어떤 테이블에서 무엇을 뽑아야 하는가?)
   - `transactions` 전체 테이블
   - `customer_id` 고객 ID
1. **조건 분석:**
   -  A, B 배정 -> CASE
   - 전체 고객별 : GROUP BY
1. **사용할 문법:**
   - `CASE … WHEN … THEN … ELSE … END`
   - `GROUP BY`
---
## 정답 쿼리 (Solution)

```sql
-- 여기에 작성한 쿼리를 붙여넣으세요.
SELECT customer_id,
	CASE
	WHEN customer_id%10=0 THEN 'A'
	ELSE 'B'
	END AS bucket
FROM transactions
GROUP BY customer_id
ORDER BY customer_id
```

---
##  오답 노트 & 배운 점 (Retrospective)

-  **내가 실수한 부분:**
	- `HAVING` 절을 써서 비율(10%)을 제한해야 하나 고민했음
	- 하지만 이 쿼리는 **실험 대상 필터링 쿼리**가 아니라모든 고객을 A/B 그룹으로 “할당(assign)”하는 단계
-  **새로 알게 된 함수/꿀팁:**
	- `HAVING`은 집계 결과를 필터링할 때만 사용

---
## 더 나은 풀이가 있다면?

```sql
-- 더 나은 풀이가 있을경우 
SELECT DISTINCT
       customer_id,
       CASE
         WHEN customer_id % 10 = 0 THEN 'A'
         ELSE 'B'
       END AS bucket
FROM transactions
ORDER BY customer_id;

```

- `GROUP BY`는 **집계용**
- `DISTINCT`는 **중복 제거용**

> 고객 단위로 한 번만 뽑는구나 즉시 이해가능