---
tags:
  - SQL_TEST
related:
  - "[[Aggregation_GROUP_BY]]"
source: solvesql
difficulty:
  - Lv.2
status: 🟩 해결
---
##  해결 전략 (Code Before Think)

> 2017년 1월 한 달 동안 택배사에 전달되었지만 배송 완료는 되지 않은 주문 건수를 택배사 도착일을 기준으로 집계하는 쿼리를 작성해주세요.
> 쿼리 결과는 택배사 도착일을 기준으로 오름차순 정렬

1. **타겟 데이터:** (어떤 테이블에서 무엇을 뽑아야 하는가?)
   - `olist_orders_dataset` 테이블
   - `order_delivered_customer_date` : 배송완료시각
   - `order_delivered_carrier_date` : 배송시작시각
1. **조건 분석:**
   - 2017년 1월 한 달 동안
   - 고객에 도착하지 않았을때 `order_delivered_customer_date` 컬럼의 값은 `null`으로 저장됩니다.
1. **사용할 문법:**
   - GROUP BY 
   - WHERE
   - ::DATE
---
## 정답 쿼리 (Solution)

```sql
-- 여기에 작성한 쿼리를 붙여넣으세요.
SELECT
order_delivered_carrier_date::DATE as delivered_carrier_date
,COUNT(*) as orders
FROM olist_orders_dataset
WHERE order_delivered_carrier_date::DATE >='2017-01-01' AND order_delivered_carrier_date::DATE <'2017-02-01'
AND order_delivered_customer_date IS NULL
GROUP BY order_delivered_carrier_date::DATE
ORDER BY delivered_carrier_date ASC
```

---
##  오답 노트 & 배운 점 (Retrospective)

-  **내가 실수한 부분:**
	- 처음에 `order_delivered_customer_date IS NULL` 조건을 이미 걸어놓고, `COUNT(order_delivered_customer_date)` 를 사용함
	- `COUNT(컬럼)` 은 **NULL 값을 세지 않는다**는 특성을 놓침 -> 그 결과, 실제로는 주문이 존재하는데도 `orders` 값이 0으로 나오는 착각 발생

-  **새로 알게 된 함수/꿀팁:**
	- `COUNT(*)` : 조건을 만족하는 **행 전체 개수**
	- `COUNT(컬럼)` : 해당 컬럼이 **NULL이 아닌 행만 카운트**
	- NULL 필터링 후 집계할 때는 `COUNT(*)`가 안전

---
## 더 나은 풀이가 있다면?

```sql
-- 더 나은 풀이가 있을경우 
```
